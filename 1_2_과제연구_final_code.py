# -*- coding: utf-8 -*-
"""1-2 과제연구_final_code

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1fj1ZgTnX1FlGxZfvDM1Vi5Ry-ngwWK7c
"""

dnalength = 750
number = 1
how_often = 10 #10개 중 1개 꼴로 오류

import random
dna = ['A','T','G','C']

original_folder_name = "1-2 과제연구 염기서열 데이터"  # a 폴더 이름
original_file_name = f"{dnalength}_{number}.txt"  # b 파일 이름
original_file_path = os.path.join(drive_path, original_folder_name, original_file_name)

with open(original_file_path, 'r') as file:
    original_sequence = file.read()  # 파일의 모든 내용을 읽음


# Parameters
sequence_length = dnalength
error_types = {"deletion": 0.4, "substitution": 0.43, "insertion": 0.17}
error_sequence = original_sequence
error_location_list = []


for i in range(sequence_length // how_often):
    error_location = random.randint(0,len(error_sequence) -1)
    a = random.random()
    error_location_list.append(error_location)
    if a < 0.4: #삭제
      error_sequence = error_sequence[:error_location] + error_sequence[error_location+1:]
    elif a < 0.83: #대체
      error_sequence = error_sequence[:error_location] + dna[(dna.index(error_sequence[error_location])+1)%4] + error_sequence[error_location+1:]
    else: #삽입
      error_sequence = error_sequence[:error_location+1] + dna[random.randint(0,3)] + error_sequence[error_location+1:]


print(error_location_list)
print(original_sequence)
print(error_sequence)


# Google Drive에 마운트된 경로
drive_path = "/content/drive/My Drive"
folder_name = "1-2 과제연구 염기서열 오류 데이터"  # a 폴더 이름
file_name = f"{dnalength}_{number}_error_{how_often}.txt"  # b 파일 이름
file_path = os.path.join(drive_path, folder_name, file_name)


# 폴더가 존재하지 않으면 생성
os.makedirs(os.path.join(drive_path, folder_name), exist_ok=True)

# 문자열을 파일에 쓰기
with open(file_path, 'w') as file:
    file.write(error_sequence)

print(f"문자열이 Google Drive의 {file_path}에 저장되었습니다.")

#nr3b.h Numerical Recipes 라이브러리

import numpy as np


def SQR(x):
    """Returns the square of x."""
    return x * x


def SIGN(a, b):
    """Returns the absolute value of a with the sign of b."""
    return abs(a) if b >= 0 else -abs(a)


def MAX(a, b):
    """Returns the maximum of a and b."""
    return a if a > b else b


def MIN(a, b):
    """Returns the minimum of a and b."""
    return a if a < b else b


def SWAP(a, b):
    """Swaps the values of a and b."""
    return b, a


# **에러 처리 클래스**
class THROWexception(Exception):
    """Custom exception for Numerical Recipes errors."""
    def __init__(self, message):
        super().__init__(message)


# **NRvector 클래스**
class NRvector:
    """Numerical Recipes vector implementation."""
    def __init__(self, n, init_val=0):
        self.data = np.full(n, init_val, dtype=np.float64)

    def __getitem__(self, idx):
        return self.data[idx]

    def __setitem__(self, idx, value):
        self.data[idx] = value

    def size(self):
        return len(self.data)

    def resize(self, new_size, preserve=True):
        if preserve:
            new_data = np.zeros(new_size, dtype=self.data.dtype)
            new_data[: min(new_size, self.size())] = self.data[: min(new_size, self.size())]
            self.data = new_data
        else:
            self.data = np.zeros(new_size, dtype=self.data.dtype)

    def __str__(self):
        return str(self.data)


# **NRmatrix 클래스**
class NRmatrix:
    """Numerical Recipes matrix implementation."""
    def __init__(self, rows, cols, init_val=0):
        self.data = np.full((rows, cols), init_val, dtype=np.float64)

    def __getitem__(self, idx):
        return self.data[idx]

    def __setitem__(self, idx, value):
        self.data[idx] = value

    def nrows(self):
        return self.data.shape[0]

    def ncols(self):
        return self.data.shape[1]

    def resize(self, new_rows, new_cols, preserve=True):
        if preserve:
            new_data = np.zeros((new_rows, new_cols), dtype=self.data.dtype)
            min_rows = min(new_rows, self.nrows())
            min_cols = min(new_cols, self.ncols())
            new_data[:min_rows, :min_cols] = self.data[:min_rows, :min_cols]
            self.data = new_data
        else:
            self.data = np.zeros((new_rows, new_cols), dtype=self.data.dtype)

    def transpose(self):
        transposed = self.data.T
        result = NRmatrix(transposed.shape[0], transposed.shape[1])
        result.data = transposed
        return result

    def __str__(self):
        return str(self.data)


# **NRmatrix3d 클래스**
class NRmatrix3d:
    """Numerical Recipes 3D matrix implementation."""
    def __init__(self, x, y, z, init_val=0):
        self.data = np.full((x, y, z), init_val, dtype=np.float64)

    def __getitem__(self, idx):
        return self.data[idx]

    def __setitem__(self, idx, value):
        self.data[idx] = value

    def resize(self, new_x, new_y, new_z, preserve=True):
        if preserve:
            new_data = np.zeros((new_x, new_y, new_z), dtype=self.data.dtype)
            min_x = min(new_x, self.data.shape[0])
            min_y = min(new_y, self.data.shape[1])
            min_z = min(new_z, self.data.shape[2])
            new_data[:min_x, :min_y, :min_z] = self.data[:min_x, :min_y, :min_z]
            self.data = new_data
        else:
            self.data = np.zeros((new_x, new_y, new_z), dtype=self.data.dtype)

    def __str__(self):
        return str(self.data)


# **테스트 코드**
if __name__ == "__main__":
    # **NRvector 테스트**
    print("Testing NRvector...")
    vec = NRvector(5, init_val=1)
    print("Initial vector:", vec)
    vec[2] = 10
    print("Modified vector:", vec)
    vec.resize(7)
    print("Resized vector:", vec)

    # **NRmatrix 테스트**
    print("\nTesting NRmatrix...")
    mat = NRmatrix(3, 3, init_val=2)
    print("Initial matrix:\n", mat)
    mat[1, 1] = 5
    print("Modified matrix:\n", mat)
    mat.resize(4, 4)
    print("Resized matrix:\n", mat)
    print("Transposed matrix:\n", mat.transpose())

    # **NRmatrix3d 테스트**
    print("\nTesting NRmatrix3d...")
    mat3d = NRmatrix3d(3, 3, 3, init_val=0)
    mat3d[1, 1, 1] = 7
    print("3D matrix:\n", mat3d)
    mat3d.resize(4, 4, 4)
    print("Resized 3D matrix:\n", mat3d)

#ran.h  랜덤값 생성

import time
import numpy as np


class Ran:
    def __init__(self, seed=None):
        self.v = 4101842887655102017
        self.w = 1
        if seed is None:
            seed = self.timeseed()
        self.u = seed ^ self.v
        self.int64()
        self.v = self.u
        self.int64()
        self.w = self.v
        self.int64()

    def timeseed(self):
        return int(time.time() * 1000) + int(time.process_time() * 1000)

    def int64(self):
        self.u = self.u * 2862933555777941757 + 7046029254386353087
        self.v ^= (self.v >> 17)
        self.v ^= (self.v << 31)
        self.v ^= (self.v >> 8)
        self.w = 4294957665 * (self.w & 0xffffffff) + (self.w >> 32)
        x = self.u ^ (self.u << 21)
        x ^= (x >> 35)
        x ^= (x << 4)
        return (x + self.v) ^ self.w

    def doub(self):
        return 5.42101086242752217E-20 * self.int64()

    def int32(self):
        return self.int64() & 0xffffffff

    def int8(self):
        return self.int64() & 0xff


class Ranq1:
    def __init__(self, seed):
        self.v = 4101842887655102017
        self.v ^= seed
        self.v = self.int64()

    def int64(self):
        self.v ^= (self.v >> 21)
        self.v ^= (self.v << 35)
        self.v ^= (self.v >> 4)
        return self.v * 2685821657736338717

    def doub(self):
        return 5.42101086242752217E-20 * self.int64()

    def int32(self):
        return self.int64() & 0xffffffff


class Ranq2:
    def __init__(self, seed):
        self.v = 4101842887655102017
        self.w = 1
        self.v ^= seed
        self.w = self.int64()
        self.v = self.int64()

    def int64(self):
        self.v ^= (self.v >> 17)
        self.v ^= (self.v << 31)
        self.v ^= (self.v >> 8)
        self.w = 4294957665 * (self.w & 0xffffffff) + (self.w >> 32)
        return self.v ^ self.w

    def doub(self):
        return 5.42101086242752217E-20 * self.int64()

    def int32(self):
        return self.int64() & 0xffffffff


class Ranhash:
    @staticmethod
    def int64(u):
        v = u * 3935559000370003845 + 2691343689449507681
        v ^= (v >> 21)
        v ^= (v << 37)
        v ^= (v >> 4)
        v *= 4768777513237032717
        v ^= (v << 20)
        v ^= (v >> 41)
        v ^= (v << 5)
        return v

    @staticmethod
    def int32(u):
        return Ranhash.int64(u) & 0xffffffff

    @staticmethod
    def doub(u):
        return 5.42101086242752217E-20 * Ranhash.int64(u)

#RSecc.h RS 코드

pip install reedsolo

import reedsolo
import random


class RsdecodeOut:
    def __init__(self, decoded=None, errs_detected=0, errs_corrected=0, err_number=0, recoverable=False):
        self.decoded = decoded or []
        self.errs_detected = errs_detected
        self.errs_corrected = errs_corrected
        self.err_number = err_number
        self.recoverable = recoverable


class MakeerasuresOut:
    def __init__(self, codeword=None, location=None):
        self.codeword = codeword or []
        self.location = location or []


class RSECC:
    def __init__(self):
        self.rs = reedsolo.RSCodec(10)  # Adjust parity size as needed

    def rsencode(self, message):
        """
        Encode a message using Reed-Solomon.
        """
        return self.rs.encode(bytearray(message))

    def rsdecode(self, received, locations=None):
        """
        Decode a received message using Reed-Solomon.
        """
        try:
            decoded = self.rs.decode(bytearray(received), erase_pos=locations)
            return RsdecodeOut(decoded=list(decoded), recoverable=True)
        except reedsolo.ReedSolomonError as e:
            # Errors detected but not recoverable
            return RsdecodeOut(errs_detected=len(received), errs_corrected=0, recoverable=False)

    def makeerasures(self, incodeword, nerase):
        """
        Introduce erasures (known error locations) in a codeword.
        """
        codeword = list(incodeword)
        locations = random.sample(range(len(codeword)), nerase)
        for loc in locations:
            codeword[loc] = 0  # Simulate erasure (set to 0)
        return MakeerasuresOut(codeword=codeword, location=locations)

    def makeerrors(self, incodeword, nerror):
        """
        Introduce random errors in a codeword.
        """
        codeword = list(incodeword)
        error_positions = random.sample(range(len(codeword)), nerror)
        for pos in error_positions:
            codeword[pos] ^= random.randint(1, 255)  # Apply a random error
        return codeword

#DNAcode.h

import random
from typing import List, Tuple, Union

class CreatemesspacketOut:
    def __init__(self, packet=None, plaintext=None):
        self.packet = packet or []
        self.plaintext = plaintext or []


class DnatomessOut:
    def __init__(self, mpacket=None, epacket=None, baddecodes=0, erasures=0):
        self.mpacket = mpacket or []
        self.epacket = epacket or []
        self.baddecodes = baddecodes
        self.erasures = erasures


class CorrectmesspacketOut:
    def __init__(self, packet=None, tot_detect=0, tot_uncorrect=0, max_detect=0, max_uncorrect=0, toterrcodes=0):
        self.packet = packet or []
        self.tot_detect = tot_detect
        self.tot_uncorrect = tot_uncorrect
        self.max_detect = max_detect
        self.max_uncorrect = max_uncorrect
        self.toterrcodes = toterrcodes


class GetparamsOut:
    def __init__(self, NSALT=0, MAXSEQ=0, NSTAK=0, HLIMIT=0):
        self.NSALT = NSALT
        self.MAXSEQ = MAXSEQ
        self.NSTAK = NSTAK
        self.HLIMIT = HLIMIT


class GetdnaconstraintsOut:
    def __init__(self, DNAWINDOW=0, MAXGC=0, MINGC=0, MAXRUN=0):
        self.DNAWINDOW = DNAWINDOW
        self.MAXGC = MAXGC
        self.MINGC = MINGC
        self.MAXRUN = MAXRUN


class GetscoresOut:
    def __init__(self, reward=0.0, substitution=0.0, deletion=0.0, insertion=0.0, dither=0.0):
        self.reward = reward
        self.substitution = substitution
        self.deletion = deletion
        self.insertion = insertion
        self.dither = dither


class DNAcode:
    def __init__(self):
        self.params = GetparamsOut()
        self.dna_constraints = GetdnaconstraintsOut()
        self.scores = GetscoresOut()

    # Higher-level functions
    def createmesspacket(self, packno: int) -> CreatemesspacketOut:
        """ Create a message packet encoded in DNA """
        packet = [[random.randint(0, 255) for _ in range(packno)] for _ in range(3)]
        plaintext = [random.randint(0, 255) for _ in range(packno)]
        return CreatemesspacketOut(packet=packet, plaintext=plaintext)

    def protectmesspacket(self, packetin: List[List[int]]) -> List[List[int]]:
        """ Protect a message packet """
        # Example: Add simple checksum or parity
        return packetin + [[sum(row) % 256 for row in packetin]]

    def messtodna(self, mpacket: List[List[int]]) -> List[List[str]]:
        """ Convert a message packet to a DNA representation """
        dna_map = ['A', 'C', 'G', 'T']
        return [[dna_map[val % 4] for val in row] for row in mpacket]

    # Error creation
    def createerrors(self, dnabag: List[List[str]], srate: float, drate: float, irate: float) -> List[List[str]]:
        """ Introduce substitutions, deletions, and insertions as errors """
        corrupted = []
        for seq in dnabag:
            new_seq = []
            for char in seq:
                if random.random() < srate:  # Substitution
                    new_seq.append(random.choice(['A', 'C', 'G', 'T']))
                elif random.random() < drate:  # Deletion
                    continue
                elif random.random() < irate:  # Insertion
                    new_seq.append(char)
                    new_seq.append(random.choice(['A', 'C', 'G', 'T']))
                else:
                    new_seq.append(char)
            corrupted.append(new_seq)
        return corrupted

    # Decoding
    def dnatomess(self, dnapacket: List[List[str]]) -> DnatomessOut:
        """ Decode the DNA back to error-corrected message """
        # Placeholder logic: simply reverse the messtodna mapping
        mpacket = [[ord(char) % 256 for char in seq] for seq in dnapacket]
        epacket = mpacket  # Example: assume error correction succeeds
        return DnatomessOut(mpacket=mpacket, epacket=epacket, baddecodes=0, erasures=0)

    def correctmesspacket(self, packetin: List[List[int]], epacket: List[List[int]]) -> CorrectmesspacketOut:
        """ Correct a message packet """
        # Example: simple parity check
        corrected = packetin  # Assuming no uncorrected errors
        return CorrectmesspacketOut(packet=corrected)

    def extractplaintext(self, cpacket: List[List[int]]) -> List[int]:
        """ Extract plaintext from corrected packet """
        return [byte for row in cpacket for byte in row]

    # Lower-level functions
    def getversion(self) -> float:
        return 1.0  # Example version number

    def minstrandlen(self, nbytes: int) -> int:
        return nbytes * 4  # Example logic: DNA requires 4 bases per byte

    def getparams(self) -> GetparamsOut:
        return self.params

    def restoreparams(self):
        self.params = GetparamsOut()

    def setparams(self, nsalt: int, maxseq: int, nstak: int, hlimit: int):
        self.params = GetparamsOut(NSALT=nsalt, MAXSEQ=maxseq, NSTAK=nstak, HLIMIT=hlimit)

    def getdnaconstraints(self) -> GetdnaconstraintsOut:
        return self.dna_constraints

    def restorednaconstraints(self):
        self.dna_constraints = GetdnaconstraintsOut()

    def setdnaconstraints(self, dnawindow: int, maxgc: int, mingc: int, maxrun: int):
        self.dna_constraints = GetdnaconstraintsOut(DNAWINDOW=dnawindow, MAXGC=maxgc, MINGC=mingc, MAXRUN=maxrun)

    def getscores(self) -> GetscoresOut:
        return self.scores

    def restorescores(self):
        self.scores = GetscoresOut()

    def setscores(self, reward: float, substitution: float, deletion: float, insertion: float, dither: float):
        self.scores = GetscoresOut(reward=reward, substitution=substitution, deletion=deletion, insertion=insertion, dither=dither)

    def revcomp(self, arr: List[str]) -> List[str]:
        """ Reverse complement a DNA vector """
        complement = {'A': 'T', 'T': 'A', 'C': 'G', 'G': 'C'}
        return [complement[base] for base in reversed(arr)]

#testprograms.h 테스트

import numpy as np
import time
import reedsolo  # 설치 필요: pip install reedsolo

# 랜덤 생성기 (난수 발생)
def random_bytes(size):
    return np.random.randint(0, 256, size, dtype=np.uint8)

# Reed-Solomon 인코딩 함수
def rs_encode(message):
    rs = reedsolo.RSCodec(32)  # 메시지의 32바이트 패리티 생성
    return np.array(rs.encode(message.tobytes()), dtype=np.uint8)

# Reed-Solomon 디코딩 함수
def rs_decode(encoded, erasures=None):
    rs = reedsolo.RSCodec(32)
    try:
        decoded = rs.decode(encoded.tobytes(), erase_pos=erasures)
        return np.frombuffer(decoded[0], dtype=np.uint8), {
            "errs_detected": len(decoded[1]),
            "errs_corrected": len(decoded[2]),
            "recoverable": True,
            "err_number": 0,
        }
    except reedsolo.ReedSolomonError as e:
        return None, {"recoverable": False, "err_number": -1}

# 에러 추가
def make_errors(encoded, n_errors):
    errored = encoded.copy()
    for _ in range(n_errors):
        idx = np.random.randint(0, len(encoded))
        errored[idx] = np.random.randint(0, 256)
    return errored

# 비우호적 지우기
def make_erasures(encoded, n_erasures):
    erased = encoded.copy()
    erasures = []
    for _ in range(n_erasures):
        idx = np.random.randint(0, len(encoded))
        erased[idx] = 0xFF  # Erase
        erasures.append(idx)
    return erased, erasures

# main_test_RS 함수
def main_test_RS():
    np.random.seed(int(time.time()))  # 랜덤 시드
    message = random_bytes(223)
    print("Original message:", message)

    # Reed-Solomon 인코딩
    encoded = rs_encode(message)
    print("Encoded message:", encoded)

    # 에러와 지우기 적용
    n_error = 8
    n_erase = 16
    errored_message = make_errors(encoded, n_error)
    erased_message, erasures = make_erasures(errored_message, n_erase)
    print("Errored + Erased message:", erased_message)

    # 디코딩
    decoded, stats = rs_decode(erased_message, erasures)
    print("Decoded message:", decoded)
    print("Stats:", stats)

    # 결과 출력
    if decoded is not None:
        n_bad = sum(decoded[:223] != message)
        print(f"Number of mismatches: {n_bad}")
    else:
        print("Decoding failed.")

    return 0

# main_test_all 함수
def main_test_all():
    np.random.seed(int(time.time()))  # 랜덤 시드
    n_packets = 20
    srate, drate, irate = 0.0238, 0.0082, 0.0039
    bad_packets = 0
    results_summary = np.zeros(8, dtype=int)

    for ipacket in range(n_packets):
        message = random_bytes(223)

        # Encoding and Error Simulation
        encoded = rs_encode(message)
        errored_message = make_errors(encoded, int(srate * len(encoded)))
        erased_message, erasures = make_erasures(errored_message, int(drate * len(encoded)))

        # Decoding
        decoded, stats = rs_decode(erased_message, erasures)
        n_bad = sum(decoded[:223] != message) if decoded is not None else 223
        packet_ok = n_bad == 0

        # Collect statistics
        results_summary[0] += stats.get("errs_detected", 0)
        results_summary[1] += stats.get("errs_corrected", 0)
        results_summary[7] += n_bad

        print(f"Packet {ipacket}: {'OK' if packet_ok else 'NOT OK'}")
        if not packet_ok:
            bad_packets += 1

    print("Results summary:", results_summary)
    print(f"Bad packets: {bad_packets}")

    return 0

# 테스트 실행
if __name__ == "__main__":
    print("Testing RS Encoding/Decoding...")
    main_test_RS()
    print("\nTesting All Packets...")
    main_test_all()

#dna 시물레이션
import numpy as np
import random
import reedsolo  # 설치 필요: pip install reedsolo
import time

# 랜덤 DNA 서열 생성기
def random_dna(length):
    return ''.join(random.choices('ACGT', k=length))

# 메시지를 DNA로 변환
def message_to_dna(message):
    dna_map = ['A', 'C', 'G', 'T']
    dna = ''.join(dna_map[b % 4] for b in message)
    return dna

# DNA를 메시지로 변환
def dna_to_message(dna):
    dna_map = {'A': 0, 'C': 1, 'G': 2, 'T': 3}
    message = np.array([dna_map[b] for b in dna], dtype=np.uint8)
    return message

# 에러 시뮬레이션: 삽입, 삭제, 치환
def create_dna_errors(dna, srate, drate, irate):
    dna = list(dna)
    new_dna = []

    for i in range(len(dna)):
        # Substitution 에러
        if random.random() < srate:
            new_dna.append(random.choice('ACGT'.replace(dna[i], '')))
        else:
            new_dna.append(dna[i])

        # Insertion 에러
        if random.random() < irate:
            new_dna.append(random.choice('ACGT'))

    # Deletion 에러
    final_dna = []
    for base in new_dna:
        if random.random() >= drate:
            final_dna.append(base)

    return ''.join(final_dna)

# DNA 인코딩 및 시뮬레이션
def simulate_dna_encoding(message, srate, drate, irate):
    # 메시지를 DNA로 변환
    dna = message_to_dna(message)
    print(f"Original DNA: {dna}")

    # 에러 추가
    errored_dna = create_dna_errors(dna, srate, drate, irate)
    print(f"Errored DNA: {errored_dna}")

    # 디코딩 시뮬레이션 (길이 동기화)
    if len(errored_dna) < len(dna):
        errored_dna += 'A' * (len(dna) - len(errored_dna))  # 패딩 추가
    elif len(errored_dna) > len(dna):
        errored_dna = errored_dna[:len(dna)]  # 초과된 부분 잘라냄

    # DNA를 메시지로 변환
    recovered_message = dna_to_message(errored_dna)
    return dna, errored_dna, recovered_message

# RS 및 DNA 시뮬레이션 통합
def main_test_dna():
    np.random.seed(int(time.time()))
    random.seed(int(time.time()))

    message = np.random.randint(0, 256, 223, dtype=np.uint8)
    print("Original message:", message)

    # RS 인코딩
    rs = reedsolo.RSCodec(32)
    encoded = np.array(rs.encode(message.tobytes()), dtype=np.uint8)
    print("RS Encoded message:", encoded)

    # DNA 시뮬레이션 파라미터
    srate, drate, irate = 0.0238, 0.0082, 0.0039

    # DNA 시뮬레이션 실행
    original_dna, errored_dna, recovered_message = simulate_dna_encoding(encoded, srate, drate, irate)

    # RS 디코딩
    decoded_message = None  # 기본값 설정
    try:
        decoded = rs.decode(recovered_message.tobytes())
        decoded_message = np.frombuffer(decoded, dtype=np.uint8)
        print("Decoded message:", decoded_message)
    except reedsolo.ReedSolomonError as e:
        print("Decoding failed:", str(e))
        decoded_message = np.array([])  # 디코딩 실패 시 빈 배열로 처리

    # 결과 비교
    if decoded_message.size > 0 and np.array_equal(decoded_message[:223], message):
        print("Message recovered successfully!")
    else:
        print("Message recovery failed.")

# 실행
if __name__ == "__main__":
    main_test_dna()

# **Levenshtein 거리 최적화 알고리즘**

def levenshtein_optimized(s1, s2):
    if len(s1) < len(s2):
        s1, s2 = s2, s1  # Ensure s1 is the longer string

    previous_row = range(len(s2) + 1)  # Initial row

    for i, c1 in enumerate(s1):
        current_row = [i + 1]
        for j, c2 in enumerate(s2):
            insertions = previous_row[j + 1] + 1
            deletions = current_row[j] + 1
            substitutions = previous_row[j] + (c1 != c2)
            current_row.append(min(insertions, deletions, substitutions))
        previous_row = current_row

    return previous_row[-1]

from joblib import Parallel, delayed

from typing import List

def calculate_cell(i, j, previous_row, current_row, s1, s2):
    """
    Helper function to calculate the Levenshtein distance for a specific cell.
    """
    insertions = previous_row[j + 1] + 1
    deletions = current_row[j] + 1
    substitutions = previous_row[j] + (s1[i] != s2[j])
    return min(insertions, deletions, substitutions)

def levenshtein_parallel(corrupted_dna: List[str], reference_dna: List[str]) -> float:
    """
    Parallelized Levenshtein distance calculation between two DNA sequences.
    """
    if len(corrupted_dna) < len(reference_dna):
        corrupted_dna, reference_dna = reference_dna, corrupted_dna  # Ensure corrupted_dna is longer.

    # Initialize the previous row with incremental values
    previous_row = list(range(len(reference_dna) + 1))

    for i, c1 in enumerate(corrupted_dna):
        current_row = [i + 1]  # Start each row with the corresponding index
        for j, c2 in enumerate(reference_dna):
            value = calculate_cell(i, j, previous_row, current_row, corrupted_dna, reference_dna)
            current_row.append(value)
        previous_row = current_row

    return previous_row[-1]

    # Parallel computation of Levenshtein distance for all pairs
    distances = Parallel(n_jobs=-1)(
        delayed(calculate_cell)(i, j, corrupted_dna, reference_dna) for i in range(len(corrupted_dna)) for j in range(len(reference_dna))
    )

    # Return the minimum Levenshtein distance between any corrupted DNA and reference DNA
    return min(distances)

class DNAcode:
    def __init__(self):
        self.params = GetparamsOut()
        self.dna_constraints = GetdnaconstraintsOut()
        self.scores = GetscoresOut()

    # Higher-level functions
    def createmesspacket(self, packno: int) -> CreatemesspacketOut:
        """ Create a message packet encoded in DNA """
        packet = [[random.randint(0, 255) for _ in range(packno)] for _ in range(3)]
        plaintext = [random.randint(0, 255) for _ in range(packno)]
        return CreatemesspacketOut(packet=packet, plaintext=plaintext)

    def protectmesspacket(self, packetin: List[List[int]]) -> List[List[int]]:
        """ Protect a message packet """
        # Example: Add simple checksum or parity
        return packetin + [[sum(row) % 256 for row in packetin]]

    def messtodna(self, mpacket: List[List[int]]) -> List[List[str]]:
        """ Convert a message packet to a DNA representation """
        dna_map = ['A', 'C', 'G', 'T']
        return [[dna_map[val % 4] for val in row] for row in mpacket]

    # Error creation
    def createerrors(self, dnabag: List[List[str]], srate: float, drate: float, irate: float) -> List[List[str]]:
        """ Introduce substitutions, deletions, and insertions as errors """
        corrupted = []
        for seq in dnabag:
            new_seq = []
            for char in seq:
                if random.random() < srate:  # Substitution
                    new_seq.append(random.choice(['A', 'C', 'G', 'T']))
                elif random.random() < drate:  # Deletion
                    continue
                elif random.random() < irate:  # Insertion
                    new_seq.append(char)
                    new_seq.append(random.choice(['A', 'C', 'G', 'T']))
                else:
                    new_seq.append(char)
            corrupted.append(new_seq)
        return corrupted

    # Decoding
    def dnatomess(self, dnapacket: List[List[str]]) -> DnatomessOut:
        """ Decode the DNA back to error-corrected message """
        # Placeholder logic: simply reverse the messtodna mapping
        mpacket = [[ord(char) % 256 for char in seq] for seq in dnapacket]
        epacket = mpacket  # Example: assume error correction succeeds
        return DnatomessOut(mpacket=mpacket, epacket=epacket, baddecodes=0, erasures=0)

    def correctmesspacket(self, packetin: List[List[int]], epacket: List[List[int]]) -> CorrectmesspacketOut:
        """ Correct a message packet """
        # Example: simple parity check
        corrected = packetin  # Assuming no uncorrected errors
        return CorrectmesspacketOut(packet=corrected)

    def extractplaintext(self, cpacket: List[List[int]]) -> List[int]:
        """ Extract plaintext from corrected packet """
        return [byte for row in cpacket for byte in row]

    # Lower-level functions
    def getversion(self) -> float:
        return 1.0  # Example version number

    def minstrandlen(self, nbytes: int) -> int:
        return nbytes * 4  # Example logic: DNA requires 4 bases per byte

    def getparams(self) -> GetparamsOut:
        return self.params

    def restoreparams(self):
        self.params = GetparamsOut()

    def setparams(self, nsalt: int, maxseq: int, nstak: int, hlimit: int):
        self.params = GetparamsOut(NSALT=nsalt, MAXSEQ=maxseq, NSTAK=nstak, HLIMIT=hlimit)

    def getdnaconstraints(self) -> GetdnaconstraintsOut:
        return self.dna_constraints

    def restorednaconstraints(self):
        self.dna_constraints = GetdnaconstraintsOut()

    def setdnaconstraints(self, dnawindow: int, maxgc: int, mingc: int, maxrun: int):
        self.dna_constraints = GetdnaconstraintsOut(DNAWINDOW=dnawindow, MAXGC=maxgc, MINGC=mingc, MAXRUN=maxrun)

    def getscores(self) -> GetscoresOut:
        return self.scores

    def restorescores(self):
        self.scores = GetscoresOut()

    def setscores(self, reward: float, substitution: float, deletion: float, insertion: float, dither: float):
        self.scores = GetscoresOut(reward=reward, substitution=substitution, deletion=deletion, insertion=insertion, dither=dither)

    def revcomp(self, arr: List[str]) -> List[str]:
        """ Reverse complement a DNA vector """
        complement = {'A': 'T', 'T': 'A', 'C': 'G', 'G': 'C'}
        return [complement[base] for base in reversed(arr)]

class HEDGESImproved(DNAcode):
    def recover_dna(self, corrupted_dna: List[str], reference_dna: List[str], method="optimized") -> List[str]:
        """
        Recover DNA using Levenshtein distance calculation with optimization and parallelism.

        Args:
            corrupted_dna: List of corrupted DNA sequences.
            reference_dna: List of reference DNA sequences.
            method: "optimized" for memory-optimized recovery, "parallel" for parallelized recovery.

        Returns:
            List of recovered DNA sequences.
        """
        recovered_dna = []

        for corrupted_seq in corrupted_dna:
            min_distance = float('inf')
            best_match = corrupted_seq

            for ref_seq in reference_dna:
                if method == "optimized":
                    distance = levenshtein_optimized(corrupted_seq, ref_seq)
                elif method == "parallel":
                    distance = levenshtein_parallel(corrupted_seq, ref_seq)
                else:
                    raise ValueError("Unknown method. Use 'optimized' or 'parallel'.")

                if distance < min_distance:
                    min_distance = distance
                    best_match = ref_seq

            recovered_dna.append(best_match)

        return recovered_dna

# 테스트 코드
if __name__ == "__main__":
    dna_code_improved = HEDGESImproved()

    # 메시지 생성 및 보호
    message_packet = dna_code_improved.createmesspacket(10)
    protected_packet = dna_code_improved.protectmesspacket(message_packet.packet)
    dna_packet = dna_code_improved.messtodna(protected_packet)

    print("Original DNA Packet:", dna_packet)

    # 에러 도입
    corrupted_dna = dna_code_improved.createerrors(dna_packet, 0.1, 0.05, 0.02)
    print("Corrupted DNA:", corrupted_dna)

    # 복구 시도: 메모리 최적화 방식
    recovered_dna_optimized = dna_code_improved.recover_dna(corrupted_dna, dna_packet, method="optimized")
    print("Recovered DNA (Optimized):", recovered_dna_optimized)

    # 복구 시도: 병렬화 방식
    recovered_dna_parallel = dna_code_improved.recover_dna(corrupted_dna, dna_packet, method="parallel")
    print("Recovered DNA (Parallel):", recovered_dna_parallel)

def levenshtein_with_operations(s1, s2):
    n, m = len(s1), len(s2)
    dp = [[0] * (m + 1) for _ in range(n + 1)]
    operations = [[[] for _ in range(m + 1)] for _ in range(n + 1)]  # 연산 추적용

    # 초기화 (빈 문자열에 대한 변환 비용)
    for i in range(n + 1):
        dp[i][0] = i  # 삭제 비용
        operations[i][0] = [("delete", i - 1)] * i
    for j in range(m + 1):
        dp[0][j] = j  # 삽입 비용
        operations[0][j] = [("insert", j - 1)] * j

    # DP 테이블 채우기
    for i in range(1, n + 1):
        for j in range(1, m + 1):
            if s1[i - 1] == s2[j - 1]:  # 문자가 같으면 비용 0
                dp[i][j] = dp[i - 1][j - 1]
                operations[i][j] = operations[i - 1][j - 1]
            else:
                # 삽입, 삭제, 대체 비용 계산
                insertion = dp[i][j - 1] + 1
                deletion = dp[i - 1][j] + 1
                substitution = dp[i - 1][j - 1] + 1

                # 최소 비용 선택
                min_cost = min(insertion, deletion, substitution)
                dp[i][j] = min_cost

                if min_cost == substitution:
                    operations[i][j] = operations[i - 1][j - 1] + [("substitute", i - 1, j - 1)]
                elif min_cost == insertion:
                    operations[i][j] = operations[i][j - 1] + [("insert", j - 1)]
                elif min_cost == deletion:
                    operations[i][j] = operations[i - 1][j] + [("delete", i - 1)]

    # Levenshtein 거리와 연산 추적 반환
    return dp[n][m], operations[n][m]


# 테스트
s1 = "kitten"
s2 = "sitting"
distance, ops = levenshtein_with_operations(s1, s2)

print(f"Levenshtein 거리: {distance}")
print("오류 위치와 유형:")
for op in ops:
    print(op)

import time
import numpy as np

dnalength = 500
number = 1
how_often = 10

def levenshtein_distance(seq1, seq2):
    """
    Calculate the Levenshtein distance (edit distance) between two sequences.
    Returns both the distance and the backtrack matrix for path reconstruction.
    """
    len1, len2 = len(seq1), len(seq2)
    dp = np.zeros((len1 + 1, len2 + 1), dtype=int)

    # Initialize base cases
    for i in range(len1 + 1):
        dp[i][0] = i
    for j in range(len2 + 1):
        dp[0][j] = j

    # Fill the DP matrix
    for i in range(1, len1 + 1):
        for j in range(1, len2 + 1):
            cost = 0 if seq1[i - 1] == seq2[j - 1] else 1
            dp[i][j] = min(
                dp[i - 1][j] + 1,  # Deletion
                dp[i][j - 1] + 1,  # Insertion
                dp[i - 1][j - 1] + cost  # Substitution
            )

    return dp[len1][len2], dp


def traceback_edits(seq1, seq2, dp):
    """
    Trace back the edits from the DP matrix to find error locations and types.
    Returns a list of edits in the format [(type, pos1, pos2)].
    """
    edits = []
    i, j = len(seq1), len(seq2)

    while i > 0 or j > 0:
        if i > 0 and dp[i][j] == dp[i - 1][j] + 1:
            edits.append(("deletion", i - 1, j))  # Deletion in seq1
            i -= 1
        elif j > 0 and dp[i][j] == dp[i][j - 1] + 1:
            edits.append(("insertion", i, j - 1))  # Insertion in seq1
            j -= 1
        else:
            if seq1[i - 1] != seq2[j - 1]:
                edits.append(("substitution", i - 1, j - 1))  # Substitution
            i -= 1
            j -= 1

    return edits[::-1]  # Reverse to get edits in order


def correct_errors(seq1, seq2):
    """
    Corrects errors in seq1 using seq2 as the reference sequence.
    Returns the corrected sequence and a list of edits made.
    """
    distance, dp = levenshtein_distance(seq1, seq2)
    edits = traceback_edits(seq1, seq2, dp)

    corrected_seq = list(seq1)
    for edit in edits:
        if edit[0] == "deletion":
            corrected_seq.pop(edit[1])  # Remove the incorrect character
        elif edit[0] == "insertion":
            corrected_seq.insert(edit[1], seq2[edit[2]])  # Insert missing character
        elif edit[0] == "substitution":
            corrected_seq[edit[1]] = seq2[edit[2]]  # Replace with correct character

    return "".join(corrected_seq), edits


drive_path = "/content/drive/My Drive"
original_folder_name = "1-2 과제연구 염기서열 데이터"  # a 폴더 이름
original_file_name = f"{dnalength}_{number}.txt"  # b 파일 이름
error_folder_name = "1-2 과제연구 염기서열 오류 데이터"  # a 폴더 이름
error_file_name = f"{dnalength}_{number}_error_{how_often}.txt"  # b 파일 이름

original_file_path = os.path.join(drive_path, original_folder_name, original_file_name)
error_file_path = os.path.join(drive_path, error_folder_name, error_file_name)

with open(original_file_path, 'r') as file:
    original_sequence = file.read().strip()  # 파일의 모든 내용을 읽음

with open(error_file_path, 'r') as file:
    corrupted_sequence = file.read().strip()  # 파일의 모든 내용을 읽음

if __name__ == "__main__":
    # Start measuring time
    start_time = time.time()

    # Perform error correction
    corrected_sequence, edits = correct_errors(corrupted_sequence, original_sequence)

    # End measuring time
    end_time = time.time()

    # Print the results
    print("Original Sequence: ", original_sequence)
    print("Corrupted Sequence:", corrupted_sequence)
    print("Corrected Sequence:", corrected_sequence)
    print("Edits:", edits)
    print(len(edits))

    # Print the execution time
    print("Execution Time: {:.6f} seconds".format(end_time - start_time))